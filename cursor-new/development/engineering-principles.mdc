---
description: Software Engineering Principles
globs: ["**/*.py", "**/*.js", "**/*.ts", "**/*.java", "**/*.go", "**/*.rs"]
alwaysApply: true
---

# Software Engineering Principles

## MANDATORY PRE-DEVELOPMENT CHECKLIST

**CRITICAL**: Before writing ANY code, complete this checklist:

### 1. DRY Check
- [ ] **MANDATORY**: Search for existing similar functionality
- [ ] **MANDATORY**: Enhance existing code instead of creating new files
- [ ] **MANDATORY**: Use parameters/flags to add features to existing classes
- [ ] **MANDATORY**: Avoid code duplication

### 2. SOLID Check
- [ ] **MANDATORY**: Single responsibility per class
- [ ] **MANDATORY**: Extend existing classes instead of creating duplicates
- [ ] **MANDATORY**: Use dependency injection for flexibility
- [ ] **MANDATORY**: Keep interfaces focused and specific

### 3. KISS Check
- [ ] **MANDATORY**: Use the simplest solution that works
- [ ] **MANDATORY**: Avoid unnecessary complexity
- [ ] **MANDATORY**: Write readable and maintainable code

### 4. YAGNI Check
- [ ] **MANDATORY**: Build only what's needed now
- [ ] **MANDATORY**: Avoid premature optimization
- [ ] **MANDATORY**: Don't build for hypothetical future needs

### 5. Refactoring First Check
- [ ] **MANDATORY**: Consider enhancing existing code first
- [ ] **MANDATORY**: Add optional parameters to existing classes
- [ ] **MANDATORY**: Maintain backward compatibility

### 6. File Creation Check
- [ ] **MANDATORY**: Do I really need a new file, or can I enhance existing ones?
- [ ] **MANDATORY**: If creating new files, is it absolutely necessary?
- [ ] **MANDATORY**: Follow the existing project structure

**VIOLATION CONSEQUENCES**: If you create duplicate files without completing this checklist, you MUST:
1. Stop immediately
2. Delete the duplicate files
3. Refactor to enhance existing code
4. Complete the checklist before proceeding

## COMMON VIOLATIONS AND CORRECTIONS

### ❌ WRONG: Creating Duplicate Files
```python
# BAD: Creating timestamped_data_pipeline.py
class TimestampedDataPipelineManager:
    def __init__(self, storage_mode: str = "test"):
        # Duplicate of DataPipelineManager with slight changes

# BAD: Creating __main__timestamped.py  
class TimestampedPricesCollector(PricesCollector):
    def __init__(self):
        # Duplicate collector with different pipeline
```

### ✅ CORRECT: Enhancing Existing Files
```python
# GOOD: Enhance existing DataPipelineManager
class DataPipelineManager:
    def __init__(self, use_timestamped_storage: bool = False, storage_mode: str = "production"):
        # Add optional parameters to existing class
        if use_timestamped_storage:
            self.object_storage = TimestampedObjectStorageManager()
        else:
            self.object_storage = ObjectStorageManager()

# GOOD: Add command-line flags to existing __main__.py
parser.add_argument('--timestamped-storage', action='store_true')
```

### ❌ WRONG: Code Duplication
```python
# BAD: Duplicating database insertion methods
class TimestampedDataPipelineManager:
    async def _insert_prices(self, data, symbol):
        # Same logic as DataPipelineManager._insert_prices
```

### ✅ CORRECT: Reusing Existing Code
```python
# GOOD: Use existing methods with parameters
class DataPipelineManager:
    async def _store_in_object_storage(self, data_type, data, symbol, metadata):
        if self.use_timestamped_storage:
            return self.object_storage.store_fmp_data_with_timestamping(...)
        else:
            # Use existing logic
```

## ENFORCEMENT RULES

1. **MANDATORY**: Always complete the pre-development checklist
2. **MANDATORY**: Search for existing functionality before creating new code
3. **MANDATORY**: Enhance existing code with parameters/flags before creating new files
4. **MANDATORY**: Maintain backward compatibility when enhancing existing code
5. **MANDATORY**: Follow SOLID principles in all implementations
6. **MANDATORY**: Keep solutions simple and focused on current requirements

## Core Engineering Principles

### DRY (Don't Repeat Yourself)
- **Definition**: Avoid duplication of code, data, or logic
- **Implementation**: Extract common functionality into reusable functions/classes, use configuration files, create shared libraries
- **Benefits**: Reduced maintenance, consistency, fewer bugs

### SOLID Principles
- **SRP**: Single Responsibility Principle - one reason to change per class
- **OCP**: Open/Closed Principle - open for extension, closed for modification
- **LSP**: Liskov Substitution Principle - derived classes must be substitutable for base classes
- **ISP**: Interface Segregation Principle - clients shouldn't depend on interfaces they don't use
- **DIP**: Dependency Inversion Principle - depend on abstractions, not concretions

### KISS (Keep It Simple, Stupid)
- **Definition**: Prefer simple solutions over complex ones
- **Implementation**: Choose simple algorithms, use clear readable code, avoid unnecessary abstractions
- **Benefits**: Easier to understand, maintain, and debug

### YAGNI (You Aren't Gonna Need It)
- **Definition**: Don't implement features until they are actually needed
- **Implementation**: Focus on current requirements, avoid premature optimization, refactor when requirements change
- **Benefits**: Faster delivery, less complexity, easier maintenance

### Abstraction
- **Definition**: Hide complex implementation details and show only essential features
- **Implementation**: Use abstract classes and interfaces, hide implementation details, provide simple clear APIs
- **Benefits**: Easier to understand and use, better maintainability

### Modularity
- **Definition**: Divide system into independent, self-contained components
- **Implementation**: Create focused single-purpose modules, minimize inter-module dependencies, use clear module interfaces
- **Benefits**: Independent development and testing, easier maintenance, better scalability